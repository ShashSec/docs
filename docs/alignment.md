# Alignment

Alignment is the process of merging a new subgraph generated by [rt](https://github.com/stucco/rt) with the full knowledge graph.

There are two broad categories of alignment: 

1. Merging new nodes that have canonical names / unique IDs (e.g. CVE #):
  * If a matching canonical name is *not* found in the knowledge graph, add the node.
  * If a matching canonical name is found in the knowledge graph, [merge properties](#merge-properties) and [merge edges](#merge-edges).
2. Merging nodes without canonical names / unique IDs (e.g. malware). Some of these nodes may not have a canonical name, others may have a canoncial name but it is not available:
  * [Identify equivalent nodes](#identify-equivalent-nodes) and score the confidence that the two nodes refer to the same domain concept.

## General Concerns/Issues
The section attempts to highlight issues that the current alignment process either needs to resolve.

1. The alignment rule set will need to be based on the ontology properties which are reflected in the JSON schema.  As such, any new rules developed should be verified against this schema (similar to XSD in XML).
2. Rule construction may want to leverage a DSL to make construction and verification of the rules easier to manage.
3. As rules are constructed are these rules maintained in a DB or loaded via file
4. Manual Correction Tool
	* Ability to revert/override modifications to the GraphDB if there are incorrect insertions
	* Ability to add content without having to go through the pipeline
	* See the provenance on a node/edge and know what entries made that contribution or had the same contribution
5. Consider provide a holding queue (Parking Lot) for entries that have enough conflicting evidence that manual intervention is needed.
6. Log provenance information on changes/updates on edges and nodes.
7. When updates occur on either a node or edge the result is:
	* Overwrite content
	* Append content (simple merge)
	* Merge Content (identify what portions should be combined)
8. Need to determine for different nodes/edges what comparison measure should be used. What kinds of comparison measures are needed. How much of deviation results in creation of a new node/edge instance, updates or parking lot.
	* For canonical names or IDs the comparison the function should be an equality measure
	* For dates we need to consider time stamps that vary with only year down to the second (i.e., general to precise).  How will we deal with this broad range (unless we provide range values)?
	* For unstructured text there are several approaches but this will depend upon the property in question.
9. Meta-Rules will need to be used to make sure that that updates will be smart.  For example, new sources of information may provide old content and shouldn't overwrite current content.  Checking time stamps to know what content is most recent.


## Research Avenues
There are several venues to deal with the alignment problem in other domains.  In the Database domain this is called the merge/purge problem of combining different databases.  The theory is similar however the underlying structures are different because we are using a graph database whereas your standard relational DB is row-column oriented.  Part of this task will be exploring what functional pieces can be leverage from the DB community and what pieces can be leveraged from the graph community. 
Things to Research:
	* Approximate subgraph matching with graph edit distance.  This will help identify which sub-graphs are most likely a match.  However, it won't be conclusive as additional functions need to be applied at the individuals levels to determine the update/insertion action.

## Merge Properties

When merging two nodes or edges where the new and existing values of a property differ, the updated value will be determined by some function that is specified for that property. The updated value may be (a) one of the two conflicting values, (b) a new value derived from both input values, or (c) an array-like object with both values. These functions may make use of any node properties, such as the new or existing node's confidence score, source(s), or published date(s).

General process when merging nodes (properties that had `null` for either the existing or new value can be handled in the same way):

* **resolve value**: for each conflicting property, identify the updated value to insert into the knowledge graph. e.g.:  

```
existing_node["conflicting_property"] = resolve_property_with_strategy(conflicting_property, existing_node, new_node)
```

* **update graph**: update `existing_node.conflicting_property` in the knowledge graph. `new_node` will not be added to graph.

*Note*:  Edges to/from `new_node` in the subgraph will be created in the knowledge graph to `existing_node`. (This assumes all nodes from the subgraph are added to the knowledge graph before edges.)

Example resolution functions:

    //publishedDate is an integer unix timestamp
    resolve_property_with_newest(property_name, existing_node, new_node) {
      if (existing_node["publishedDate"] < new_node["publishedDate"])
        return new_node["property_name"]
      else
        return existing_node["property_name"]
    }

    //confidence ("score") is a float between 0 and 1
    resolve_property_by_confidence(property_name, existing_node, new_node) {
      if (existing_node["score"] < new_node["score"]) 
        return new_node["property_name"]
      else
        return existing_node["property_name"]
    }

Other examples could include a weighted average by confidence scores, or functions that may be unique to a specific property, e.g. an account's `lastLogin` property might always take the newest value, or a vulnerability's `patchAvailable` property might never change to `false` once a `true` value has been seen.

Merging node confidence score properties will always use the same function across all node types. Other properties may share the same functions.


## Merge Edges

Nodes can be added or merged into the knowledge graph. The edges associated with those nodes need to be added or merged as well. If both nodes were merged or added to the knowledge graph, the strategy for merging is based on whether or not there is an existing edge.

  * *No* existing edge exists, add the egde.
  * An existing edge exists, merge the properties of both edges, as [described above](#merge-properties).


## Identify Equivalent Nodes

Identify if a new node is equivalent to an existing node for a subset of nodes in the knowledge graph. The scope of identifying equivalent nodes can be narrowed down by:

1. only searching the same node type.
2. only searching nodes that have identical values for important properties, based on some metadata defined in the ontology.

Based on this subset of nodes, a comparison algorithm will run to assign a similarity score between the new node and each other node in the subset.

  * This score reflects the probability that these two nodes are describing the same entity.
  * It will be a float between 0 and 1.
  * This is calculated by function TBD.
  * If the value is 0, (or below some threshold TBD,) the edge should be excluded.
  * If the value is 1, (or above some threshold TBD,) the two nodes should be merged.

- - - - -

# Examples

### Trivial cases: adding a new node, adding a new group of nodes/edges, adding the same new node multiple times.

### Matching IDs, one node, adding a reference to list

**Old State:**

    {
      "vertices": [
        {
          "_id": "CVE-1999-0002",
          "_type": "vertex",
          "source": "CVE",
          "description": "Buffer overflow in NFS mountd gives root access to remote attackers, mostly in Linux systems.",
          "references": [
            "CERT:CA-98.12.mountd",
            "http://www.ciac.org/ciac/bulletins/j-006.shtml",
            "http://www.securityfocus.com/bid/121",
            "XF:linux-mountd-bo"
          ],
          "status": "Entry",
          "score": 1.0
        }
      ]
    }

**Update:**

    {
      "vertices": [
        {
          "_id": "CVE-1999-0002",
          "_type": "vertex",
          "source": "CVE",
          "description": "",
          "references": [
            "ftp://patches.sgi.com/support/free/security/advisories/19981006-01-I"
          ],
          "status": "Entry",
          "score": 1.0
        }
      ]
    }

**New State:** combine list of references

    {
      "vertices": [
        {
          "_id": "CVE-1999-0002",
          "_type": "vertex",
          "source": "CVE",
          "description": "Buffer overflow in NFS mountd gives root access to remote attackers, mostly in Linux systems.",
          "references": [
            "ftp://patches.sgi.com/support/free/security/advisories/19981006-01-I",
            "CERT:CA-98.12.mountd",
            "http://www.ciac.org/ciac/bulletins/j-006.shtml",
            "http://www.securityfocus.com/bid/121",
            "XF:linux-mountd-bo"
          ],
          "status": "Entry",
          "score": 1.0
        }
      ]
    }

### Matching IDs, one node, update a property based on revision date/time

**Old State:**

    {
      "vertices": [
        {
          "_id": "CVE-2013-4878",
          "_type": "vertex",
          "vertexType": "vulnerability",
          "source": "NVD",
          "description": "The default configuration of Parallels Plesk Panel 9.0.x and 9.2.x on UNIX, and Small Business Panel 10.x on UNIX, has an improper ScriptAlias directive for phppath, which makes it easier for remote attackers to execute arbitrary code via a crafted request.",
          "publishedDate": "2013-07-18T12:51:56.227-04:00",
          "modifiedDate": "2013-07-18T12:51:56.227-04:00",
          "score": 1.0,
          "cweNumber": "CWE-264",
          "cvssScore": 6.8,
          "accessVector": "NETWORK",
          "accessComplexity": "MEDIUM",
          "accessAuthentication": "NONE",
          "confidentialityImpact": "PARTIAL",
          "integrityImpact": "PARTIAL",
          "availabilityImpact": "PARTIAL",
          "cvssDate": "2013-07-19T16:37:00.000-04:00"
        }
      ]
    }

**Update:**

    {
      "vertices": [
        {
          "_id": "CVE-2013-4878",
          "_type": "vertex",
          "vertexType": "vulnerability",
          "source": "NVD",
          "description": "The default configuration of Parallels Plesk Panel 9.0.x and 9.2.x on UNIX, and Small Business Panel 10.x on UNIX, has an improper ScriptAlias directive for phppath, which makes it easier for remote attackers to execute arbitrary code via a crafted request, a different vulnerability than CVE-2012-1823.",
          "publishedDate": "2013-07-18T12:51:56.227-04:00",
          "modifiedDate": "2013-07-19T16:51:21.577-04:00",
          "score": 1.0,
          "cweNumber": "CWE-264",
          "cvssScore": 6.8,
          "accessVector": "NETWORK",
          "accessComplexity": "MEDIUM",
          "accessAuthentication": "NONE",
          "confidentialityImpact": "PARTIAL",
          "integrityImpact": "PARTIAL",
          "availabilityImpact": "PARTIAL",
          "cvssDate": "2013-07-19T16:37:00.000-04:00"
        }
      ]
    }

**New State:** overwrite old description with new, like `resolve_property_with_newest` example above.

    {
      "vertices": [
        {
          "_id": "CVE-2013-4878",
          "_type": "vertex",
          "vertexType": "vulnerability",
          "source": "NVD",
          "description": "The default configuration of Parallels Plesk Panel 9.0.x and 9.2.x on UNIX, and Small Business Panel 10.x on UNIX, has an improper ScriptAlias directive for phppath, which makes it easier for remote attackers to execute arbitrary code via a crafted request, a different vulnerability than CVE-2012-1823.",
          "publishedDate": "2013-07-18T12:51:56.227-04:00",
          "modifiedDate": "2013-07-19T16:51:21.577-04:00",
          "score": 1.0,
          "cweNumber": "CWE-264",
          "cvssScore": 6.8,
          "accessVector": "NETWORK",
          "accessComplexity": "MEDIUM",
          "accessAuthentication": "NONE",
          "confidentialityImpact": "PARTIAL",
          "integrityImpact": "PARTIAL",
          "availabilityImpact": "PARTIAL",
          "cvssDate": "2013-07-19T16:37:00.000-04:00"
        }
      ]
    }

### Matching IDs, one node, data from two sources.  update a property based on confidence scores.  Maintain timestamps as appropriate.

**Old State:**

    {
      "vertices": [
        {
          "_id": "CVE-2012-5217",
          "_type": "vertex",
          "vertexType": "vulnerability",
          "source": "Something that isn't NVD",
          "description": "HP System Management Homepage (SMH) before 7.2.1 allows remote attackers to bypass intended access restrictions and obtain sensitive information via unspecified vectors, a different vulnerability than CVE-2013-2355.",
          "publishedDate": "2013-07-22T07:19:33.783-04:00",
          "modifiedDate": "2013-07-26T00:00:00.000-04:00",
          "score": 0.6
        }
      ]
    }

**Update:**

    {
      "vertices": [
        {
          "_id": "CVE-2013-5217",
          "_type": "vertex",
          "vertexType": "vulnerability",
          "source": "NVD",
          "description": "** REJECT **  DO NOT USE THIS CANDIDATE NUMBER. ConsultIDs: CVE-2012-5217.  Reason: This candidate is a duplicate of CVE-2012-5217.  A typo caused the wrong ID to be used.  Notes: All CVE users should reference CVE-2012-5217 instead of this candidate.  All references and descriptions in this candidate have been removed to prevent accidental usage.",
          "publishedDate": "2013-07-22T07:20:46.637-04:00",
          "modifiedDate": "2013-07-22T07:20:47.053-04:00",
          "score": 1.0
        }
      ]
    }

**New State:** overwrite less reliable description with the more reliable one, like `resolve_property_by_confidence` example above.

    {
      "vertices": [
        {
          "_id": "CVE-2013-5217",
          "_type": "vertex",
          "vertexType": "vulnerability",
          "source": "NVD",
          "description": "** REJECT **  DO NOT USE THIS CANDIDATE NUMBER. ConsultIDs: CVE-2012-5217.  Reason: This candidate is a duplicate of CVE-2012-5217.  A typo caused the wrong ID to be used.  Notes: All CVE users should reference CVE-2012-5217 instead of this candidate.  All references and descriptions in this candidate have been removed to prevent accidental usage.",
          "publishedDate": "2013-07-22T07:19:33.783-04:00",
          "modifiedDate": "2013-07-26T00:00:00.000-04:00",
          "score": 1.0
        }
      ]
    }

### Partial overlap cases (multiple nodes, some of which match, but with additional nodes and/or edges.)

### Finding and merging matching nodes, without matching names (Missing or differing _id fields)