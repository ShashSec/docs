# Alignment

Alignment is the process of merging a new subgraph generated by [rt](https://github.com/stucco/rt) with the full knowledge graph.

There are two broad categories of alignment: 

1. Merging new nodes that have canonical names / unique IDs (e.g. CVE #):
  * If a matching canonical name is *not* found in the knowledge graph, add the node.
  * If a matching canonical name is found in the knowledge graph, [merge properties](#merge-properties) and [merge edges](#merge-edges).
2. Merging nodes without canonical names / unique IDs (e.g. malware). Some of these nodes may not have a canonical name, others may have a canoncial name but it is not available:
  * [Identify equivalent nodes](#identify-equivalent-nodes) and score the confidence that the two nodes refer to the same domain concept.


## Merge Properties

When merging two nodes or edges where the new and existing values of a property differ, the updated value will be determined by some function that is specified for that property. The updated value may be (a) one of the two conflicting values, (b) a new value derived from both input values, or (c) an array-like object with both values. These functions may make use of any node properties, such as the new or existing node's confidence score, source(s), or published date(s).

General process when merging nodes (properties that had `null` for either the existing or new value can be handled in the same way):

* **resolve value**: for each conflicting property, identify the updated value to insert into the knowledge graph. e.g.:  

```
existing_node["conflicting_property"] = resolve_property_with_strategy(conflicting_property, existing_node, new_node)
```

* **update graph**: update `existing_node.conflicting_property` in the knowledge graph. `new_node` will not be added to graph.

*Note*:  Edges to/from `new_node` in the subgraph will be created in the knowledge graph to `existing_node`. (This assumes all nodes from the subgraph are added to the knowledge graph before edges.)

Example resolution functions:

    //publishedDate is an integer unix timestamp
    resolve_property_with_newest(property_name, existing_node, new_node) {
      if (existing_node["publishedDate"] < new_node["publishedDate"])
        return new_node["property_name"]
      else
        return existing_node["property_name"]
    }

    //confidence is a float between 0 and 1
    resolve_property_by_confidence(property_name, existing_node, new_node) {
      if (existing_node["confidence"] < new_node["confidence"]) 
        return new_node["property_name"]
      else
        return existing_node["property_name"]
    }

Other examples could include a weighted average by confidence scores, or functions that may be unique to a specific property, e.g. an account's `lastLogin` property might always take the newest value, or a vulnerability's `patchAvailable` property might never change to `false` once a `true` value has been seen.

Merging node confidence score properties will always use the same function across all node types. Other properties may share the same functions.


## Merge Edges

Nodes can be added or merged into the knowledge graph. The edges associated with those nodes need to be added or merged as well. If both nodes were merged or added to the knowledge graph, the strategy for merging is based on whether or not there is an existing edge.

  * *No* existing edge exists, add the egde.
  * An existing edge exists, merge the properties of both edges, as [described above](#merge-properties).


## Identify Equivalent Nodes

Identify if a new node is equivalent to an existing node for a subset of nodes in the knowledge graph. The scope of identifying equivalent nodes can be narrowed down by:

1. only searching the same node type.
2. only searching nodes that have identical values for important properties, based on some metadata defined in the ontology.

Based on this subset of nodes, a comparison algorithm will run to assign a similarity score between the new node and each other node in the subset.

  * This score reflects the probability that these two nodes are describing the same entity.
  * It will be a float between 0 and 1.
  * This is calculated by function TBD.
  * If the value is 0, (or below some threshold TBD,) the edge should be excluded.
  * If the value is 1, (or above some threshold TBD,) the two nodes should be merged.